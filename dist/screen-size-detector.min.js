var ScreenSizeDetector;ScreenSizeDetector=(()=>{var i={579:i=>{i.exports=class{constructor(i={}){const t=i;if(t.heightChange&&"function"!=typeof t.heightChange)throw this.typeErrorMessageBuilder('"heightChange"',"function",t.heightChange);if(t.widthChange&&"function"!=typeof t.widthChange)throw this.typeErrorMessageBuilder('"widthChange"',"function",t.widthChange);if(t.sizeChange&&"function"!=typeof t.sizeChange)throw this.typeErrorMessageBuilder('"sizeChange"',"function",t.sizeChange);t.widthDefinitions&&!this.isEmptyObject(t.widthDefinitions)&&this.validateWidthDefinition(t.widthDefinitions),window.addEventListener("resize",(()=>this.resizeHandler()));const e={heightChange:()=>{},widthChange:()=>{},sizeChange:()=>{},widthDefinitions:{smartwatch:{min:0,max:319,inclusion:"[]"},mobile:{min:320,max:480,inclusion:"[]"},tablet:{min:481,max:768,inclusion:"[]",onEnter:()=>{},whileInside:()=>{},onLeave:()=>{}},laptop:{min:769,max:1024,inclusion:"[]"},desktop:{min:1025,max:1200,inclusion:"[]"},largedesktop:{min:1201,max:1/0,inclusion:"[]"}}};t.widthDefinitions&&(this.isEmptyObject(t.widthDefinitions)?e.widthDefinitions={}:(e.widthDefinitions={...e.widthDefinitions,...t.widthDefinitions},delete t.widthDefinitions));const n={...e,...t};for(let[i,t]of Object.entries(n))this[i]=t;this.width=Math.max(document.documentElement.clientWidth||0,window.innerWidth||0),this.height=Math.max(document.documentElement.clientHeight||0,window.innerHeight||0);const s={};Object.keys(this.widthDefinitions).forEach((i=>s[i]=!1)),this.is=s,this.computeIsAndCallbacks()}_aOrAn(i){return["a","e","i","o","u"].includes(i.charAt(0))?"an":"a"}addWidthDefinitions(i,t=(()=>{})){this.validateWidthDefinition(i,!1);for(let[t,e]of Object.entries(i))this.widthDefinitions[t]=e;this.computeIsAndCallbacks(),t(this)}validateWidthDefinition(i,t=!0){const e=t?"widthDefinition":"the main object";if("object"!=typeof i)throw this.typeErrorMessageBuilder(t?e:"The main object","object",i);const n={min:["number"],max:["number"],inclusion:["string"]};for(let[t,s]of Object.entries(i)){if("object"!=typeof s)throw this.typeErrorMessageBuilder(`"${t}" inside ${e}`,"object",s);let i=!0,o=Object.keys(s);for(let t of Object.keys(n))o.includes(t)||(i=!1);if(!i)throw`Invalid ${e} for "${t}" due to missing required object key(s). "${t}" has to be an object containing "min" (Number), "max" (Number) and "inclusion" (String)`;for(let[i,o]of Object.entries(s)){const h=n[i];if(h&&!h.includes(typeof o))throw this.typeErrorMessageBuilder(`"${i}" for "${t}" inside ${e}`,h.join(", or "),o);if(s.min>s.max)throw`Error: The value of "min" has to be equals to or less than the value of "max" for "${t}" inside ${e}`;if(s.min>s.max)throw`Error: The value of "max" has to be equals to or greater than the value of "min" for "${t}" inside ${e}`;if("inclusion"===i&&!this.isValidInclusion(o))throw`Error: Invalid inclusion provided for screen size "${t}". The only valid value is a string with the value "[]", "()", "[)" or "()"`;const r=["whileInside","onEnter","onLeave"];for(let n of r)if(i===n&&"function"!=typeof o)throw this.typeErrorMessageBuilder(`"${i}" for "${t}" inside ${e}`,"function if defined",o)}}}removeWidthDefinition(i,t=(()=>{})){if(!this.widthDefinitions[i])throw`"${i}" is not found in "widthDefinitions" for removal`;delete this.widthDefinitions[i],t(this)}setCallback(i,t,e,n=(()=>{})){if(!this.widthDefinitions[i])throw`Error: "${i}" is not found in "widthDefinitions". You need to define it first by using the "defineWidth" method`;const s={enter:"onEnter",inside:"whileInside",leave:"onLeave"};if(!Object.keys(s).includes(t))throw`Error: The second parameter (when) has to be a string with a value of either "enter", "inside" or "leave". "${t}" was supplied`;const o=s[t],h=typeof e;if("function"!==h)throw this.typeErrorMessageBuilder(`"${o}" for "${screenWidthName}" inside "widthDefinitions"`,"function",h);this.widthDefinitions[screenWidthName][o]=()=>e(this),this.computeIsAndCallbacks(),n(this)}removeCallback(i,t,e=(()=>{})){if(!this.widthDefinitions[i])throw`"${i}" is not found in "widthDefinitions" for callback removal`;const n={enter:"onEnter",inside:"whileInside",leave:"onLeave"};if(!Object.keys(n).includes(t))throw`Error: The second parameter (when) has to be a string with a value of either "enter", "inside" or "leave". "${t}" was supplied`;const s=n[t];delete this.widthDefinitions[screenWidthName][s],e(this)}typeErrorMessageBuilder(i,t,e){const n=typeof e;return`Error: ${i} has to be ${this._aOrAn(t)} ${t} but ${this._aOrAn(n)} ${n} was provided`}isValidInclusion(i){return/^[\[\(]{1}[\]\)]{1}/.test(i)}isWidthIncluded(i,t,e,n){if(!this.isValidInclusion(n))throw`Error: Invalid inclusion provided for screen size "${i}". The only valid combinations are "[]", "()", "[)" and "()"`;const s="["==n[0],o="]"==n[1];let h=s?this.width>=t:this.width>t,r=o?this.width<=e:this.width<e;return h&&r}isEmptyObject(i){for(const t in i)if(i.hasOwnProperty(t))return!1;return!0}computeIsAndCallbacks(){for(let[i,t]of Object.entries(this.widthDefinitions)){let e=this.is[i];const n=this.isWidthIncluded(i,t.min,t.max,t.inclusion);this.is[i]=n,n&&this.widthDefinitions[i].whileInside&&this.widthDefinitions[i].whileInside(this),!1===e&&n&&this.widthDefinitions[i].onEnter&&this.widthDefinitions[i].onEnter(this),!0===e&&!n&&this.widthDefinitions[i].onLeave&&this.widthDefinitions[i].onLeave(this)}}resizeHandler(){const i=this.width,t=this.height;this.width=Math.max(document.documentElement.clientWidth||0,window.innerWidth||0),this.height=Math.max(document.documentElement.clientHeight||0,window.innerHeight||0),this.computeIsAndCallbacks(),i!==this.width&&t===this.height?this.widthChange(this):i===this.width&&t!==this.height?this.heightChange(this):i&&t&&this.width&&this.height&&i!==this.width&&t!==this.height&&this.sizeChange(this)}}}},t={};return function e(n){if(t[n])return t[n].exports;var s=t[n]={exports:{}};return i[n](s,s.exports,e),s.exports}(579)})();